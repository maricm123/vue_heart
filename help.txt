// const data = new Uint8Array(value);
// console.log("Raw HRM data:", data);

// // üîç pravilno parsiranje HRM paketa
// const flags = data[0];
// let bpm;
// // if (flags & 0x01) {
// //   bpm = data[1] | (data[2] << 8); // 16-bit little endian
// // } else {
// //   bpm = data[1]; // 8-bit
// // }
// if ((flags & 0x01) && data.length >= 3) {
//   bpm = data[1] | (data[2] << 8); // 16-bit
// } else {
//   bpm = data[1]; // 8-bit
// }







<script setup lang="ts">
import { reactive, ref } from 'vue';
import { BleClient, numbersToDataView } from '@capacitor-community/bluetooth-le';
import wsStore from '@/stores/wsStore'; // your websocket store

// ---------------------------
// Reactive state
// ---------------------------
const connectingDevices = reactive({});
const devices = reactive({});          // clientId -> device object
const deviceClientMap = reactive({});  // deviceId -> clientId
const sessionsStarted = reactive({});  // track active sessions
const sessionIds = reactive({});       // track session IDs

// ---------------------------
// Constants
// ---------------------------
const HEART_RATE_SERVICE = '0000180d-0000-1000-8000-00805f9b34fb';
const HEART_RATE_MEASUREMENT_CHARACTERISTIC = '00002a37-0000-1000-8000-00805f9b34fb';
const BATTERY_SERVICE = '180f'; // optional

// ---------------------------
// Utility
// ---------------------------
function parseHeartRate(value: DataView): number {
  const flags = value.getUint8(0);
  const rate16Bits = flags & 0x1;
  return rate16Bits ? value.getUint16(1, true) : value.getUint8(1);
}

// ---------------------------
// Disconnect callback
// ---------------------------
function onDeviceDisconnected(deviceId: string) {
  const clientId = deviceClientMap[deviceId];
  console.warn(`‚ö†Ô∏è Device for client ${clientId} disconnected:`, deviceId);

  // Cleanup
  delete devices[clientId];
  delete deviceClientMap[deviceId];

  // Optional: auto-reconnect
  reconnectDevice(clientId, deviceId, 3);
}

// ---------------------------
// Connect to a device
// ---------------------------
export async function connectDevice(client: any) {
  if (connectingDevices[client.id]) return;

  connectingDevices[client.id] = true;

  try {
    await BleClient.initialize();

    const device = await BleClient.requestDevice({
      services: [HEART_RATE_SERVICE],
      optionalServices: [BATTERY_SERVICE],
    });

    // Connect with per-device disconnect callback
    await BleClient.connect(device.deviceId, onDeviceDisconnected);

    // Save mappings
    devices[client.id] = device;
    deviceClientMap[device.deviceId] = client.id;

    // Start HR notifications
    await BleClient.startNotifications(
      device.deviceId,
      HEART_RATE_SERVICE,
      HEART_RATE_MEASUREMENT_CHARACTERISTIC,
      (value) => {
        const bpm = parseHeartRate(value);

        // Update reactive store for UI
        wsStore.bpmsFromWsCoach[client.id] = bpm;

        // Send to backend if session active
        if (sessionsStarted[client.id]) {
          wsStore.client[client.id] = client.id;
          sendBpmToBackend(client, bpm, device, sessionIds[client.id]);
        }
      }
    );

    console.log(`Connected to device for client ${client.id}`, device);

  } catch (err) {
    console.error('BLE error:', err);
  } finally {
    connectingDevices[client.id] = false;
  }
}

// ---------------------------
// Optional: Auto-reconnect
// ---------------------------
async function reconnectDevice(clientId: string, deviceId: string, retries = 3) {
  if (retries <= 0) {
    console.error(`Failed to reconnect device for client ${clientId}`);
    return;
  }

  console.log(`Attempting reconnect for client ${clientId} (${retries} retries left)`);
  try {
    await BleClient.connect(deviceId, onDeviceDisconnected);
    console.log(`Reconnected device for client ${clientId}`);
  } catch (err) {
    setTimeout(() => reconnectDevice(clientId, deviceId, retries - 1), 2000);
  }
}

// ---------------------------
// Example: send BPM to backend
// ---------------------------
function sendBpmToBackend(client, bpm, device, sessionId) {
  // implement your API call here
  console.log(`Sending BPM=${bpm} for client ${client.id} session ${sessionId}`);
}
</script>






  // // ws.value = new WebSocket("ws://localhost:8000/ws/bpm/")
  // // ws.value = new WebSocket(import.meta.env.VITE_WS_API_URL)
  // const token = localStorage.getItem('access')
  // // ws.value = new WebSocket(`wss://heartapp.dev/ws/bpm/?token=${token}`);
  // // ws.value = new WebSocket("wss://heartapp.dev/ws/bpm/");
  // // ws.value = new WebSocket(`ws://localhost:8000/ws/bpm/?token=${token}`);
  // ws.value = new WebSocket(`ws://13.48.248.110:8000/ws/bpm/?token=${token}`);
  // // console.log("Connecting to WS:", import.meta.env.VITE_WS_API_URL)
  // console.log("Connecting to WS:", ws.value.url)
  // ws.value.onopen = () => console.log("‚úÖ WebSocket connected")













  <template>
  <div class="tv-wrapper">
    <!-- üü¶ Header -->
    <header class="tv-header">
      <div class="header-left">
        üèãÔ∏è‚Äç‚ôÇÔ∏è Live Training Monitor
      </div>
      <div class="header-right">
        <i class="pi pi-clock" style="margin-right: 8px;"></i>
        {{ time }}
      </div>
    </header>

    <!-- üü© Main Grid -->
    <div class="livetv-container" :style="gridStyle">
      <div
        v-if="bpmsEntries.length === 0"
        class="no-sessions"
      >
        <h1>No active sessions yet</h1>
        <p>Waiting for clients to connect.</p>
      </div>

      <div
        v-for="[clientId] in bpmsEntries"
        :key="clientId"
        class="session-tile"
      >
        <h1>{{ client_name[1] }}</h1>
        <h1>BPM: {{ bpmsForGym[clientId] }}</h1>
        <h1>Calories: {{ caloriesForGym[clientId] }}</h1>
        <h1>Coach: {{ coach[clientId] }}</h1>
        <h1>‚è±Ô∏è {{ timersStore.formatDuration(seconds[clientId]) }}</h1>
      </div>
    </div>
  </div>
</template>

<script setup>
import { onUnmounted, computed, onMounted, ref, watchEffect } from "vue";
import { webSocketStore } from "@/store/webSocketStore";
import { useSessionTimersStore } from "@/store/sessionTimerStore";
import { storeToRefs } from "pinia";

// üß≠ PrimeVue icons (for clock icon)
import "primeicons/primeicons.css";

const wsStore = webSocketStore();
const { bpmsForGym, caloriesForGym, coach, client_name, seconds } = storeToRefs(wsStore);

const timersStore = useSessionTimersStore();
const { timers } = storeToRefs(timersStore);

const bpmsEntries = computed(() => Object.entries(bpmsForGym.value));
const gridStyle = ref({});

// üïí Belgrade Clock
const time = ref("");

function updateClock() {
  const now = new Date();
  const belgradeTime = new Intl.DateTimeFormat("en-GB", {
    timeZone: "Europe/Belgrade",
    hour: "2-digit",
    minute: "2-digit",
    second: "2-digit",
    hour12: false,
  }).format(now);
  time.value = belgradeTime;
}

let clockInterval = null;

onMounted(() => {
  updateClock();
  clockInterval = setInterval(updateClock, 1000);

  // start timers for existing sessions
  Object.keys(wsStore.bpmsForGym).forEach((clientId) => {
    if (!timersStore.timers[clientId]) {
      timersStore.startTimerFor(clientId);
    }
  });
});

onUnmounted(() => {
  clearInterval(clockInterval);
});

watchEffect(() => {
  const count = bpmsEntries.value.length;

  if (count === 1) {
    gridStyle.value = { gridTemplateColumns: "1fr", gridTemplateRows: "1fr" };
  } else if (count === 2) {
    gridStyle.value = { gridTemplateColumns: "1fr 1fr", gridTemplateRows: "1fr" };
  } else if (count <= 4) {
    gridStyle.value = { gridTemplateColumns: "1fr 1fr", gridTemplateRows: "1fr 1fr" };
  } else if (count <= 6) {
    gridStyle.value = { gridTemplateColumns: "1fr 1fr 1fr", gridTemplateRows: "1fr 1fr" };
  } else {
    gridStyle.value = { gridTemplateColumns: "1fr 1fr 1fr", gridTemplateRows: "1fr 1fr 1fr" };
  }
});
</script>

<style scoped>
/* üñ•Ô∏è Fullscreen layout */
.tv-wrapper {
  width: 100vw;
  height: 100vh;
  overflow: hidden; /* ‚ùå No scrollbars */
  display: flex;
  flex-direction: column;
  background: black;
}

/* üî∑ Header styling */
.tv-header {
  height: 70px;
  background: #111;
  color: #fff;
  font-size: 2rem;
  font-weight: 600;
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 0 40px;
  border-bottom: 2px solid #333;
  letter-spacing: 1px;
}

.header-left {
  display: flex;
  align-items: center;
}

.header-right {
  display: flex;
  align-items: center;
  font-size: 1.8rem;
  font-weight: 500;
  color: #00e0ff;
}

/* üü© Main grid */
.livetv-container {
  flex: 1;
  display: grid;
  gap: 10px;
  padding: 10px;
  overflow: hidden; /* üö´ No scroll */
  background: black;
}

/* üß± Session tiles */
.session-tile {
  background: linear-gradient(145deg, #2b2b2b, #1a1a1a);
  border: 2px solid #444;
  border-radius: 16px;
  display: flex;
  flex-direction: column;
  justify-content: center;
  align-items: center;
  color: white;
  box-shadow: 0 0 20px rgba(0, 255, 255, 0.1);
  font-size: 3rem;
  text-align: center;
  transition: transform 0.3s ease;
}

.session-tile:hover {
  transform: scale(1.03);
  box-shadow: 0 0 30px rgba(0, 255, 255, 0.3);
}

.no-sessions {
  grid-column: 1 / -1;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  color: white;
}

h1 {
  margin: 0.2em 0;
  font-size: 3.5rem;
}
</style>
